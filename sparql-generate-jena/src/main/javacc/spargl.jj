/*
 * Copyright 2016 Ecole des Mines de Saint-Etienne.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
options
{
    //DEBUG_PARSER=true;
    JAVA_UNICODE_ESCAPE = true ;
    UNICODE_INPUT = false ;
    STATIC = false ;
}
PARSER_BEGIN(SPARQLGenerateParser)
package com.github.thesmartenergy.sparql.generate.jena.lang;
import java.util.LinkedList;
import org.apache.jena.graph.*;
import org.apache.jena.query.*;
import org.apache.jena.sparql.core.Var;
import org.apache.jena.sparql.syntax.*;
import org.apache.jena.sparql.expr.*;
import org.apache.jena.sparql.path.*;
import org.apache.jena.sparql.expr.aggregate.*;
import org.apache.jena.update.*;
import org.apache.jena.sparql.modify.request.*;
import com.github.thesmartenergy.sparql.generate.jena.query.SPARQLGenerateQuery;
import com.github.thesmartenergy.sparql.generate.jena.syntax.*;
import java.util.ArrayList;
import java.util.List;
public class SPARQLGenerateParser extends SPARQLGenerateParserBase
{ boolean allowAggregatesInExpressions = false ;  }
PARSER_END(SPARQLGenerateParser)
void GenerateUnit(): { }
{
  ByteOrderMark()
  { startQuery() ; }
  Generate() <EOF>
  { finishQuery() ; }
}
void Generate() : { }
{
  Prologue()
  GenerateQuery()
}
void GenerateQuery() : { }
{
  <GENERATE>
    { asSPARQLGenerateQuery().setQueryGenerateType() ; }
  GenerateTemplate()
  ( DatasetClause() )*
  {  List<ElementIteratorOrSource> list = new ArrayList<ElementIteratorOrSource> ();}
  ( IteratorOrSourceClause(list) )*
  {  asSPARQLGenerateQuery().setIteratorsAndSources(list);}
  ( WhereClause() )?
  SolutionModifier()
}
void GenerateTemplate() : { }
{
  <LBRACE>
  { ElementGroup elem = null; } elem = GenerateTemplateSub() { asSPARQLGenerateQuery().setGenerateTemplate(elem); }
  <RBRACE>
}
ElementGroup GenerateTemplateSub() : {  ElementGroup elg = new ElementGroup();}
{
  (
    { XTripleCollectorBGP acc = new XTripleCollectorBGP(); }
    ConstructTriples(acc) 
    { elg.addElement(new XElementGenerateTriplesBlock(acc.getBGP())); }
  )?
  ( 
    { startSubGenerate() ; Token t = null;}
    t = SubGenerateQuery()
      { int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null; }
      { SPARQLGenerateQuery q = endSubGenerate(beginLine, beginColumn) ; } 
      { elg.addElement( new ElementSubGenerate(q) ) ; }
    ( 
      { XTripleCollectorBGP acc = new XTripleCollectorBGP(); }
      ConstructTriples(acc) 
      { elg.addElement(new XElementGenerateTriplesBlock(acc.getBGP())); }
    )? 
  )*
  { return elg ; }
}
void IteratorOrSourceClause(List<ElementIteratorOrSource> list) : {}
{
    {ElementIteratorOrSource elem = null;}
  ( elem = IteratorClause()
  | elem = SourceClause() )
    { list.add(elem); }
}
ElementIterator IteratorClause() : {}
{
  { XExpr expr ; Var var;}
  <ITERATOR> 
    expr = FunctionCall() 
  <AS> 
    var = Var() 
    { return new ElementIterator(expr, var);} 
}
ElementSource SourceClause() : {}
{
  { XExpr source = null; XExpr accept = null; Var var = null ; }
  <SOURCE> 
    source = XVarOrIri() 
    ( 
      <ACCEPT> 
      accept = XVarOrIri() 
    )?
    <AS>
    var = Var()
    { return new ElementSource(source, accept, var);} 
}
Token SubGenerateQuery( ) : { Token t;}
{
  t = <GENERATE>
    { asSPARQLGenerateQuery().setQueryGenerateType() ; }
  ( 
    { String generateUri; } generateUri = SourceSelector() { asSPARQLGenerateQuery().setGenerateURI(generateUri); }
  | 
    GenerateTemplate() 
  )
  ( 
    {  List<ElementIteratorOrSource> list = new LinkedList<ElementIteratorOrSource> ();}
    ( IteratorOrSourceClause(list) )*
    {  asSPARQLGenerateQuery().setIteratorsAndSources(list);}
    ( WhereClause() )?
    SolutionModifier()
    <DOT>
  )?
  { return t; }
}
void ByteOrderMark() : {}
{
   (<BOM>)?
}
void Prologue() : {}
{
  ( BaseDecl() | PrefixDecl() )*
}
void BaseDecl() : { String iri ; }
{
  <BASE> iri = IRIREF()
  { getPrologue().setBaseURI(iri) ; }
}
void PrefixDecl() : { Token t ; String iri ; }
{
    <PREFIX> t = <PNAME_NS> iri = IRIREF()
      { String s = fixupPrefix(t.image, t.beginLine, t.beginColumn) ;
        getPrologue().setPrefix(s, iri) ; }
}
void SubSelect() :{ }
{
  SelectClause()
  WhereClause()
  SolutionModifier()
  ValuesClause()
}
void SelectClause() : { Var v ; XExpr expr ; Node n ; }
{
  <SELECT>
    { getQuery().setQuerySelectType() ; }
  ( <DISTINCT> { getQuery().setDistinct(true);}
  | <REDUCED> { getQuery().setReduced(true); }
  )?
  { allowAggregatesInExpressions = true ; }
  (
    (
      v = Var() { getQuery().addResultVar(v) ; }
    |
      (
        { v = null ; }
        <LPAREN>
        expr = Expression()
        <AS> v = Var()
        <RPAREN>
        { getQuery().addResultVar(v, expr) ; }
      )
      { getQuery().setQueryResultStar(false) ; }
    )+
  |
    <STAR> { getQuery().setQueryResultStar(true) ; }
  )
  { allowAggregatesInExpressions = false ; }
}
void DatasetClause() : {}
{
  <FROM>
  ( DefaultGraphClause() | NamedGraphClause() )
}
void DefaultGraphClause() : { String iri ; }
{
  iri = SourceSelector()
  {
    getQuery().addGraphURI(iri) ;
  }
}
void NamedGraphClause() : { String iri ; }
{
  <NAMED>
  iri = SourceSelector()
  {
    getQuery().addNamedGraphURI(iri) ;
  }
}
String SourceSelector() : { String iri ; }
{
  iri = iri() { return iri ; }
}
void WhereClause() : { Element el ; }
{
   (<WHERE>)?
   { startWherePattern() ; }
   el = GroupGraphPattern() { getQuery().setQueryPattern(el) ; }
   { finishWherePattern() ; }
}
void SolutionModifier() : { }
{
  ( GroupClause() )?
  ( HavingClause() )?
  ( OrderClause() )?
  ( LimitOffsetClauses() )?
}
void GroupClause() : { }
{
  <GROUP> <BY> ( GroupCondition() )+
}
void GroupCondition() : { Var v = null ; XExpr expr = null ; }
{
  ( expr = BuiltInCall() { getQuery().addGroupBy((Var)null, expr) ; }
  | expr = FunctionCall() { getQuery().addGroupBy((Var)null, expr) ; }
  |
    <LPAREN>
      expr = Expression()
    ( <AS> v = Var() )?
    <RPAREN>
    { getQuery().addGroupBy(v ,expr) ; }
  | v = Var()
    { getQuery().addGroupBy(v) ; }
  )
}
void HavingClause() : { }
{
    { allowAggregatesInExpressions = true ; }
    <HAVING> (HavingCondition())+
    { allowAggregatesInExpressions = false ; }
}
void HavingCondition() : { XExpr c ; }
{
  c = Constraint()
  { getQuery().addHavingCondition(c) ; }
}
void OrderClause() : { }
{
  { allowAggregatesInExpressions = true ; }
  <ORDER> <BY> ( OrderCondition() )+
  { allowAggregatesInExpressions = false ; }
}
void OrderCondition() :
{ int direction = 0 ; XExpr expr = null ; Node v = null ; }
{
  { direction = Query.ORDER_DEFAULT ; }
  (
    (
      ( <ASC> { direction = Query.ORDER_ASCENDING ; }
      | <DESC> { direction = Query.ORDER_DESCENDING ; } )
      expr = BrackettedExpression()
    )
  |
    ( expr = Constraint()
    | v = Var()
    )
  )
  { if ( v == null )
          getQuery().addOrderBy(expr, direction) ;
      else
          getQuery().addOrderBy(v, direction) ; }
}
void LimitOffsetClauses() : { }
{
  (
    LimitClause() (OffsetClause())?
  |
    OffsetClause() (LimitClause())?
  )
}
void LimitClause() : { Token t ; }
{
  <LIMIT> t = <INTEGER>
    { getQuery().setLimit(integerValue(t.image)) ; }
}
void OffsetClause() : { Token t ; }
{
  <OFFSET> t = <INTEGER>
    { getQuery().setOffset(integerValue(t.image)) ; }
}
void ValuesClause() : { Token t ; }
{
  (
    t = <VALUES>
    { startValuesClause(t.beginLine, t.beginColumn) ; }
    DataBlock()
    { finishValuesClause(t.beginLine, t.beginColumn) ; }
  )?
}
void TriplesTemplate(XTripleCollector acc) : { }
{
    TriplesSameSubject(acc)
    (<DOT> (TriplesTemplate(acc))?)?
}
Element GroupGraphPattern() : { Element el = null ; Token t ; }
{
  t = <LBRACE>
  { int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null; }
  (
    { startXSubSelect(beginLine, beginColumn) ; }
    SubSelect()
    {
      XQuery q = endXSubSelect(beginLine, beginColumn) ;
      el = new XElementSubQuery(q) ;
    }
  | el = GroupGraphPatternSub()
  )
  <RBRACE>
    { return el ; }
}
Element GroupGraphPatternSub() : { Element el = null ; }
{
      { ElementGroup elg = new ElementGroup() ; }
      { startGroup(elg) ; }
  (
    { startTriplesBlock() ; }
    el = TriplesBlock(null)
    { endTriplesBlock() ;
      elg.addElement(el) ; }
  )?
  (
    el = GraphPatternNotTriples()
    { elg.addElement(el) ; }
    (<DOT>)?
    (
      { startTriplesBlock() ; }
      el = TriplesBlock(null)
      { endTriplesBlock() ;
        elg.addElement(el) ; }
    )?
  )*
      { endGroup(elg) ; }
      { return elg ; }
}
Element TriplesBlock(XElementPathBlock acc) : { }
{
  { if ( acc == null )
        acc = new XElementPathBlock() ;
  }
  TriplesSameSubjectPath(acc)
  ( <DOT> (TriplesBlock(acc))? )?
    { return acc ; }
}
Element GraphPatternNotTriples() : { Element el = null ; }
{
 (
   el = GroupOrUnionGraphPattern()
 |
   el = OptionalGraphPattern()
 |
   el = MinusGraphPattern()
 |
   el = GraphGraphPattern()
 |
   el = ServiceGraphPattern()
 |
   el = Filter()
 |
   el = Bind()
 |
   el = InlineData()
 )
 { return el ; }
}
Element OptionalGraphPattern() : { Element el ; }
{ <OPTIONAL> el = GroupGraphPattern()
    { return new ElementOptional(el) ; }
}
Element GraphGraphPattern() : { Element el ; XExpr n ;}
{
  <GRAPH> n = XVarOrIri() el = GroupGraphPattern()
    { return new XElementNamedGraph(n, el) ; }
}
Element ServiceGraphPattern() : { Element el ; XExpr expr ; boolean silent = false ; }
{
  <SERVICE>
  (<SILENT>
   { silent=true; }
  )?
  expr = XVarOrIri()
  el = GroupGraphPattern()
    { return new XElementService(expr, el, silent) ; }
}
Element Bind() : { Var v ; XExpr expr ; }
{
  <BIND>
  <LPAREN>
  expr = Expression()
  <AS>
  v = Var()
  <RPAREN>
  { return new ElementBind(v, expr) ; }
}
Element InlineData() : { ElementData el ; Token t ; }
{
  t = <VALUES>
  { int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null; }
  { el = new ElementData() ;
    startInlineData(el.getVars(), el.getRows(), beginLine, beginColumn) ; }
  DataBlock()
  { finishInlineData(beginLine, beginColumn) ;
    return el ; }
}
void DataBlock() : { }
{
  ( InlineDataOneVar() | InlineDataFull() )
}
void InlineDataOneVar() : { Var v ; Node n ; Token t ; }
{
  v = Var()
  { emitDataBlockVariable(v) ; }
  t = <LBRACE>
  (
    n = DataBlockValue()
    { startDataBlockValueRow(-1, -1) ;
      emitDataBlockValue(n, -1, -1) ;
      finishDataBlockValueRow(-1, -1) ;
    }
  )*
  t = <RBRACE>
}
void InlineDataFull() : { Var v ; Node n ; Token t ; int beginLine; int beginColumn; }
{
  (
     <NIL>
  |
    <LPAREN>
    (v = Var() { emitDataBlockVariable(v) ; })*
    <RPAREN>
  )
  <LBRACE>
  (
    t = <LPAREN>
    { beginLine = t.beginLine; beginColumn = t.beginColumn; t = null; }
    { startDataBlockValueRow(beginLine, beginColumn) ; }
    (n = DataBlockValue()
        { emitDataBlockValue(n, beginLine, beginColumn) ; }
    ) *
    t = <RPAREN>
    { beginLine = t.beginLine; beginColumn = t.beginColumn; t = null; }
      { finishDataBlockValueRow(beginLine, beginColumn) ; }
  |
    t = <NIL>
    { beginLine = t.beginLine; beginColumn = t.beginColumn; t = null; }
      { startDataBlockValueRow(beginLine, beginColumn) ; }
      { finishDataBlockValueRow(beginLine, beginColumn) ; }
   )*
  <RBRACE>
}
Node DataBlockValue() : { Node n ; String iri ; }
{
  iri = iri() { return createNode(iri) ; }
| n = RDFLiteral() { return n ; }
| n = NumericLiteral() { return n ; }
| n = BooleanLiteral() { return n ; }
| <UNDEF> { return null ; }
}
Element MinusGraphPattern() : { Element el ; }
{
    <MINUS_P>
    el = GroupGraphPattern()
    { return new ElementMinus(el) ; }
}
Element GroupOrUnionGraphPattern() :
    { Element el = null ; ElementUnion el2 = null ; }
{
  el = GroupGraphPattern()
  ( <UNION>
    { if ( el2 == null )
      {
        el2 = new ElementUnion() ;
        el2.addElement(el) ;
      }
    }
  el = GroupGraphPattern()
    { el2.addElement(el) ; }
  )*
    { return (el2==null)? el : el2 ; }
}
Element Filter() : { XExpr c ; }
{
  <FILTER> c = Constraint()
  { return new XElementFilter(c) ; }
}
XExpr Constraint() : { XExpr c ; }
{
  ( c = BrackettedExpression()
  | c = BuiltInCall()
  | c = FunctionCall()
  )
  { return c ; }
}
XExpr FunctionCall() : { String fname ; XExprList a ; }
{
  fname = iri()
  a = ArgList()
  {
     if ( AggregateRegistry.isRegistered(fname) ) {
         if ( ! allowAggregatesInExpressions )
            throwParseException("Aggregate expression not legal at this point : "+fname, -1, -1) ;
         if( !a.isExprList() )
            throwParseException("Custom expressions not legal as argument of aggregate expressions: "+fname, -1, -1) ;
         Aggregator agg = AggregatorFactory.createCustom(true, false, fname, a.asExprList()) ;
         Expr exprAgg = getQuery().allocAggregate(agg) ;
         return new XExpr(exprAgg) ;
     }
     return new XE_Function(fname, a) ;
  }
}
XExprList ArgList() : { XExpr expr ; boolean distinct = false ;
                      XExprList args = new XExprList() ; Token t ; }
{
  (
    <NIL>
  |
    <LPAREN>
      (t = <DISTINCT> { distinct = true ; }
      { int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null; }
        {
          if ( ! allowAggregatesInExpressions )
              throwParseException("Aggregate expression not legal at this point",
                                 beginLine, beginColumn) ;
        }
      )?
      expr = Expression() { args.add(expr) ; }
      (<COMMA> expr = Expression() { args.add(expr) ; } )*
    <RPAREN>
   )
    { return args ; }
}
XExprList ExpressionList() : { XExpr expr = null ; XExprList args = new XExprList() ;}
{
  (
    <NIL>
  |
    <LPAREN>
    expr = Expression() { args.add(expr) ; }
      (<COMMA> expr = Expression() { args.add(expr) ; } )*
    <RPAREN>
  )
  { return args ; }
}
void ConstructTriples(XTripleCollector acc) : { }
{
    TriplesSameSubject(acc)
    (<DOT> (ConstructTriples(acc))? )?
}
void TriplesSameSubject(XTripleCollector acc) : { XExpr s ; }
{
  s = XVarOrTerm()
  PropertyListNotEmpty(s, acc)
|
  { XElementPathBlock tempAcc = new XElementPathBlock() ; }
  s = TriplesNode(tempAcc)
  PropertyList(s, tempAcc)
  { insert(acc, tempAcc) ; }
}
void PropertyList(XExpr s, XTripleCollector acc) : { }
{
  ( PropertyListNotEmpty(s, acc) ) ?
}
void PropertyListNotEmpty(XExpr s, XTripleCollector acc) :
    { XExpr p = null ; }
{
    p = Verb()
    ObjectList(s, p, null, acc)
  ( <SEMICOLON>
    (
       p = Verb()
      ObjectList(s, p, null, acc)
    )?
  )*
}
XExpr Verb() : { XExpr p ;}
{
  ( p = XVarOrIri() | <KW_A> { p = XnRDFtype ; } )
  { return p ; }
}
void ObjectList(XExpr s, XExpr p, XPath path, XTripleCollector acc): { XExpr o ; }
{
  Object(s, p, path, acc)
  ( <COMMA> Object(s, p, path, acc) )*
}
void Object(XExpr s, XExpr p, XPath path, XTripleCollector acc): { XExpr o ; }
{
  { XElementPathBlock tempAcc = new XElementPathBlock() ; int mark = tempAcc.mark() ; }
  o = GraphNode(tempAcc)
  { insert(tempAcc, mark, s, p, path, o) ; insert(acc, tempAcc) ; }
}
void TriplesSameSubjectPath(XTripleCollector acc) : { XExpr s ; }
{
  s = XVarOrTerm()
  PropertyListPathNotEmpty(s, acc)
|
  { XElementPathBlock tempAcc = new XElementPathBlock() ; }
  s = TriplesNodePath(tempAcc)
  PropertyListPath(s, tempAcc)
  { insert(acc, tempAcc) ; }
}
void PropertyListPath(XExpr s, XTripleCollector acc) : { }
{
  ( PropertyListPathNotEmpty(s, acc) ) ?
}
void PropertyListPathNotEmpty(XExpr s, XTripleCollector acc) :
    { XPath path = null ; XExpr p = null ; }
{
  ( path = VerbPath()
  | p = VerbSimple()
  )
  ObjectListPath(s, p, path, acc)
  ( <SEMICOLON>
    { path = null ; p = null ; }
    (
      ( path = VerbPath()
      | p = VerbSimple()
      )
      ObjectListPath(s, p, path, acc)
    )?
  )*
}
XPath VerbPath() : {XExpr p ; XPath path ; }
{
  path = Path() { return path ; }
}
XExpr VerbSimple() : { XExpr p ; }
{
  p = XVar()
  { return new XExpr( p ) ; }
}
void ObjectListPath(XExpr s, XExpr p, XPath path, XTripleCollector acc): { XExpr o ; }
{
  ObjectPath(s, p, path, acc)
  ( <COMMA> ObjectPath(s, p, path, acc) )*
}
void ObjectPath(XExpr s, XExpr p, XPath path, XTripleCollector acc): { XExpr o ; }
{
  { XElementPathBlock tempAcc = new XElementPathBlock() ; int mark = tempAcc.mark() ; }
  o = GraphNodePath(tempAcc)
  { insert(tempAcc, mark, s, p, path, o) ; insert(acc, tempAcc) ; }
}
XPath Path() : { XPath p ; }
{
  p = PathAlternative() { return p ; }
}
XPath PathAlternative() : { XPath p1 , p2 ; }
{
   p1 = PathSequence()
   (
      <VBAR> p2 = PathSequence()
      { p1 = new XP_Alt(p1, p2); }
   )*
   { return p1 ; }
}
XPath PathSequence() : { XPath p1 , p2 ; }
{
    p1 = PathEltOrInverse()
    ( <SLASH> p2 = PathEltOrInverse()
      { p1 = new XP_Seq(p1, p2) ; }
    )*
   { return p1; }
}
XPath PathElt() : { XPath p ; }
{
   p = PathPrimary()
   ( p = PathMod(p) )?
   { return p ; }
}
XPath PathEltOrInverse() : { XPath p ; }
{
   ( p = PathElt()
   | <CARAT>
     p = PathElt()
     { p = new XP_Inverse(p) ; }
   )
   { return p ; }
}
XPath PathMod(XPath p) : { long i1 ; long i2 ; }
{
   ( <QMARK> { return new XP_ZeroOrOne(p) ; }
   | <STAR> { return new XP_ZeroOrMore1(p) ; }
   | <PLUS> { return new XP_OneOrMore1(p) ; }
   )
}
XPath PathPrimary() : { XExpr expr ; XPath p ; }
{
  (
    expr = Xiri()
     { p = new XP_Link(expr) ; }
  | <KW_A>
     { p = new XP_Link(XnRDFtype) ; }
  | <BANG> p = PathNegatedPropertySet()
  | <LPAREN> p = Path() <RPAREN>
  )
 { return p ; }
}
Path PathNegatedPropertySet() : { XP_Path0 p ; XP_NegPropSet pNegSet ; }
{
  { pNegSet = new XP_NegPropSet() ; }
  ( p = PathOneInPropertySet()
    { pNegSet.add(p) ; }
  | <LPAREN>
    ( p = PathOneInPropertySet() { pNegSet.add(p) ; }
      (<VBAR> p = PathOneInPropertySet() { pNegSet.add(p) ; }) *
    )?
     <RPAREN>
  )
  { return pNegSet ; }
}
XP_Path0 PathOneInPropertySet() : { XExpr expr ; }
{
  ( expr = Xiri() { return new XP_Link(expr) ; }
  | <KW_A> { return new XP_Link(XnRDFtype) ; }
  | <CARAT>
    ( expr = Xiri() { return new XP_ReverseLink(expr) ; }
    | <KW_A> { return new XP_ReverseLink(XnRDFtype) ; }
    )
  )
}
long Integer() : {Token t ;}
{
    t = <INTEGER>
    { return integerValue(t.image) ; }
}
XExpr TriplesNode(XTripleCollectorMark acc) : { XExpr expr; }
{
  expr = Collection(acc) { return expr ; }
 |
  expr = BlankNodePropertyList(acc) { return expr ; }
}
XExpr BlankNodePropertyList(XTripleCollector acc) : { Token t ; }
{
  t = <LBRACKET>
    { XExpr expr = new XExpr( createBNode( t.beginLine, t.beginColumn) ) ; }
  PropertyListNotEmpty(expr, acc)
  <RBRACKET>
    { return expr ; }
}
XExpr TriplesNodePath(TripleCollectorMark acc) : { XExpr expr ; }
{
  expr = CollectionPath(acc) { return expr ; }
 |
  expr = BlankNodePropertyListPath(acc) { return expr ; }
}
XExpr BlankNodePropertyListPath(XTripleCollector acc) : { Token t ; }
{
  t = <LBRACKET>
    { XExpr expr = createBNode( t.beginLine, t.beginColumn) ; }
  PropertyListPathNotEmpty(expr, acc)
  <RBRACKET>
    { return expr ; }
}
XExpr Collection(XTripleCollectorMark acc) :
    { XExpr listHead = XnRDFnil ; XExpr lastCell = null ; int mark ; XExpr expr ; Token t ; }
{
  t = <LPAREN>
  { int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null; }
  (
    { XExpr cell = new XExpr( createListNode( beginLine, beginColumn) );
      if ( listHead == XnRDFnil )
         listHead = cell ;
      if ( lastCell != null )
        insert(acc, lastCell, XnRDFrest, cell) ;
      mark = acc.mark() ;
    }
    expr = GraphNode(acc)
    {
      insert(acc, mark, cell, XnRDFfirst, expr) ;
      lastCell = cell ;
    }
  ) +
  <RPAREN>
   { if ( lastCell != null )
       insert(acc, lastCell, XnRDFrest, XnRDFnil) ;
     return listHead ; }
}
XExpr CollectionPath(XTripleCollectorMark acc) :
    { XExpr listHead = XnRDFnil ; XExpr lastCell = null ; int mark ; XExpr expr ; Token t ; }
{
  t = <LPAREN>
  { int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null; }
  (
    { XExpr cell = new XExpr( createListNode( beginLine, beginColumn) );
      if ( listHead == XnRDFnil )
         listHead = cell ;
      if ( lastCell != null )
        insert(acc, lastCell, XnRDFrest, cell) ;
      mark = acc.mark() ;
    }
    expr = GraphNodePath(acc)
    {
      insert(acc, mark, cell, XnRDFfirst, expr) ;
      lastCell = cell ;
    }
  ) +
  <RPAREN>
   { if ( lastCell != null )
       insert(acc, lastCell, XnRDFrest, XnRDFnil) ;
     return listHead ; }
}
XExpr GraphNode(XTripleCollectorMark acc) : { XExpr expr ; }
{
  expr = XVarOrTerm() { return expr ; }
 |
  expr = TriplesNode(acc) { return expr ; }
}
XExpr GraphNodePath(XTripleCollectorMark acc) : { XExpr expr ; }
{
  expr = XVarOrTerm() { return expr ; }
 |
  expr = TriplesNodePath(acc) { return expr ; }
}
XExpr XVarOrTerm() : { XExpr expr ; }
{
  ( expr = XVar()
  | expr = GraphTerm()
  )
  { return expr ; }
}
XExpr XVarOrIri() : { XExpr expr ; }
{
  ( expr = XVar()
  | expr = Xiri()
  )
  { return expr ; }
}
XExpr XVarOrBlankNodeOrIri() : { XExpr expr ; }
{
  ( expr = XVar()  { return expr ; }
  | expr = Xiri()  { return expr ; }
  | { Node n; } n = BlankNode() { return new XExpr( n ) ; }
  )
}
Var Var() : { Token t ;}
{
  ( t = <VAR1> | t = <VAR2> )
  { return createVariable(t.image, t.beginLine, t.beginColumn) ; }
}
XExpr XVar() : { Token t ;}
{
 ( { Var v; } v = Var() { return new XExpr( v ); }
 | { XExpr expr; } expr = XExpression() { return expr; }
 )
}
XExpr GraphTerm() : { XExpr expr ; Node n ; }
{
  expr = Xiri() { return expr ; }
| expr = XRDFLiteral() { return expr ; }
| n = NumericLiteral() { return new XExpr( n ) ; }
| n = BooleanLiteral() { return new XExpr( n ) ; }
| n = BlankNode() { return new XExpr( n ) ; }
| <NIL> { return XnRDFnil ; }
}
XExpr XExpression() : { XExpr expr ; }
{
  <START_XEXPR>
  expr = Expression()
  <RBRACE>
  { return expr ; }
}
XExpr Expression() : { XExpr expr ; }
{
  expr = ConditionalOrExpression()
  { return expr ; }
}
XExpr ConditionalOrExpression() : { XExpr expr1, expr2 ; }
{
  expr1 = ConditionalAndExpression()
  ( <SC_OR> expr2 = ConditionalAndExpression()
    { expr1 = new XE_LogicalOr(expr1, expr2) ; }
  )*
    { return expr1 ; }
}
XExpr ConditionalAndExpression() : { XExpr expr1, expr2 ;}
{
  expr1 = ValueLogical()
  ( <SC_AND> expr2 = ValueLogical()
    { expr1 = new XE_LogicalAnd(expr1, expr2) ; }
  )*
    { return expr1 ; }
}
XExpr ValueLogical() : { XExpr expr ; }
{
  expr = RelationalExpression()
    { return expr ; }
}
XExpr RelationalExpression() : { XExpr expr1, expr2 ; XExprList a ; }
{
  expr1 = NumericExpression()
  (
    <EQ> expr2 = NumericExpression()
      { expr1 = new XE_Equals(expr1, expr2) ; }
  | <NE> expr2 = NumericExpression()
      { expr1 = new XE_NotEquals(expr1, expr2) ; }
  | <LT> expr2 = NumericExpression()
      { expr1 = new XE_LessThan(expr1, expr2) ; }
  | <GT> expr2 = NumericExpression()
      { expr1 = new XE_GreaterThan(expr1, expr2) ; }
  | <LE> expr2 = NumericExpression()
      { expr1 = new XE_LessThanOrEqual(expr1, expr2) ; }
  | <GE> expr2 = NumericExpression()
      { expr1 = new XE_GreaterThanOrEqual(expr1, expr2) ; }
  | <IN> a = ExpressionList()
      { expr1 = new XE_OneOf(expr1, a) ; }
  | <NOT> <IN> a = ExpressionList()
      { expr1 = new XE_NotOneOf(expr1, a) ; }
  )?
    { return expr1 ; }
}
XExpr NumericExpression () : { XExpr expr ; }
{
  expr = AdditiveExpression()
    { return expr ; }
}
XExpr AdditiveExpression() : { XExpr expr1, expr2, expr3 ; boolean addition ; Node n ; }
{
  expr1 = MultiplicativeExpression()
  ( <PLUS> expr2 = MultiplicativeExpression()
    { expr1 = new XE_Add(expr1, expr2) ; }
  | <MINUS> expr2 = MultiplicativeExpression()
    { expr1 = new XE_Subtract(expr1, expr2) ; }
  |
    (
      n = NumericLiteralPositive()
      {
         n = stripSign(n) ;
         expr2 = new XExpr( asExpr(n) );
         addition = true ;
      }
    |
      n = NumericLiteralNegative()
     {
         n = stripSign(n) ;
         expr2 = new XExpr( asExpr(n) );
         addition = false ;
     }
     )
    (
      ( <STAR> expr3 = UnaryExpression() { expr2 = new XE_Multiply(expr2, expr3) ; } )
    |
      ( <SLASH> expr3 = UnaryExpression() { expr2 = new XE_Divide(expr2, expr3) ; } )
    )*
    { if ( addition )
         expr1 = new XE_Add(expr1, expr2) ;
      else
         expr1 = new XE_Subtract(expr1, expr2) ;
    }
  )*
  { return expr1 ; }
}
XExpr MultiplicativeExpression() : { XExpr expr1, expr2 ; }
{
  expr1 = UnaryExpression()
  ( <STAR> expr2 = UnaryExpression()
    { expr1 = new XE_Multiply(expr1, expr2) ; }
  | <SLASH> expr2 = UnaryExpression()
    { expr1 = new XE_Divide(expr1, expr2) ; }
  )*
    { return expr1 ; }
}
XExpr UnaryExpression() : { XExpr expr ; }
{
  <BANG> expr = PrimaryExpression()
    { return new XE_LogicalNot(expr) ; }
  | <PLUS> expr = PrimaryExpression() { return new XE_UnaryPlus(expr) ; }
  | <MINUS> expr = PrimaryExpression() { return new XE_UnaryMinus(expr) ; }
  | expr = PrimaryExpression() { return expr ; }
}
XExpr PrimaryExpression() : { XExpr expr ; Node gn ; }
{
  ( expr = BrackettedExpression() { return expr ; }
  | expr = BuiltInCall() { return expr ; }
  | expr = XiriOrFunction() { return expr ; }
  | expr = XRDFLiteral() { return expr ; }
  | gn = NumericLiteral() { return asExpr(gn) ; }
  | gn = BooleanLiteral() { return asExpr(gn) ; }
  | expr = XVar() { return expr ; }
  )
}
XExpr BrackettedExpression() : { XExpr expr ; }
{
    <LPAREN> expr = Expression() <RPAREN> { return expr ; }
}
XExpr BuiltInCall() : { XExpr expr ; XExpr expr1 = null ; XExpr expr2 = null ;
                       Node gn ; XExprList a ; }
{
    expr = Aggregate() { return expr ; }
  |
    <STR> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_Str(expr) ; }
  | <LANG> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_Lang(expr) ; }
  | <LANGMATCHES>
       <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new XE_LangMatches(expr1, expr2) ; }
  | <DTYPE> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_Datatype(expr) ; }
  | <BOUND> <LPAREN> gn = Var() <RPAREN>
    { return new XE_Bound(new ExprVar(gn)) ; }
  | <IRI> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_IRI(expr) ; }
  | <URI> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_URI(expr) ; }
  | <BNODE>
    ( <LPAREN> expr1 = Expression() <RPAREN>
      { return new XE_BNode(expr1) ; }
    |
      <NIL> { return new XE_BNode() ; }
    )
  | <RAND> <NIL> { return new XE_Random() ; }
  | <ABS> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_NumAbs(expr1) ; }
  | <CEIL> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_NumCeiling(expr1) ; }
  | <FLOOR> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_NumFloor(expr1) ; }
  | <ROUND> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_NumRound(expr1) ; }
  | <CONCAT> a = ExpressionList() { return new XE_StrConcat(a) ; }
  | expr = SubstringExpression() { return expr ; }
  | <STRLEN> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_StrLength(expr1) ; }
  | expr = StrReplaceExpression() { return expr ; }
  | <UCASE> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_StrUpperCase(expr1) ; }
  | <LCASE> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_StrLowerCase(expr1) ; }
  | <ENCODE_FOR_URI> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_StrEncodeForURI(expr1) ; }
  | <CONTAINS> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new XE_StrContains(expr1, expr2) ; }
  | <STRSTARTS> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new XE_StrStartsWith(expr1, expr2) ; }
  | <STRENDS> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new XE_StrEndsWith(expr1, expr2) ; }
  | <STRBEFORE> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new XE_StrBefore(expr1, expr2) ; }
  | <STRAFTER> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new XE_StrAfter(expr1, expr2) ; }
  | <YEAR> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_DateTimeYear(expr1) ; }
  | <MONTH> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_DateTimeMonth(expr1) ; }
  | <DAY> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_DateTimeDay(expr1) ; }
  | <HOURS> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_DateTimeHours(expr1) ; }
  | <MINUTES> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_DateTimeMinutes(expr1) ; }
  | <SECONDS> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_DateTimeSeconds(expr1) ; }
  | <TIMEZONE> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_DateTimeTimezone(expr1) ; }
  | <TZ> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_DateTimeTZ(expr1) ; }
  | <NOW> <NIL> { return new XE_Now() ; }
  | <UUID> <NIL> { return new XE_UUID() ; }
  | <STRUUID> <NIL> { return new XE_StrUUID() ; }
  | <MD5> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_MD5(expr1) ; }
  | <SHA1> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_SHA1(expr1) ; }
  | <SHA256> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_SHA256(expr1) ; }
  | <SHA384> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_SHA384(expr1) ; }
  | <SHA512> <LPAREN> expr1 = Expression() <RPAREN> { return new XE_SHA512(expr1) ; }
  | <COALESCE> a = ExpressionList()
    { return new XE_Coalesce(a) ; }
  | <IF> <LPAREN> expr = Expression() <COMMA>
                  expr1 = Expression() <COMMA>
                  expr2 = Expression() <RPAREN>
    { return new XE_Conditional(expr, expr1, expr2) ; }
  | <STRLANG> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new XE_StrLang(expr1, expr2) ; }
  | <STRDT> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new XE_StrDatatype(expr1, expr2) ; }
  | <SAME_TERM> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new XE_SameTerm(expr1, expr2) ; }
  | <IS_IRI> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_IsIRI(expr) ; }
  | <IS_URI> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_IsURI(expr) ; }
  | <IS_BLANK> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_IsBlank(expr) ; }
  | <IS_LITERAL> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_IsLiteral(expr) ; }
  | <IS_NUMERIC> <LPAREN> expr = Expression() <RPAREN>
    { return new XE_IsNumeric(expr) ; }
  |
    expr = RegexExpression() { return expr ; }
  | expr = ExistsFunc() { return expr ; }
  | expr = NotExistsFunc() { return expr ; }
}
XExpr RegexExpression() :
{ XExpr expr ; XExpr patExpr = null ; XExpr flagsExpr = null ; }
{
    <REGEX>
    <LPAREN>
      expr = Expression()
      <COMMA>
      patExpr = Expression()
      ( <COMMA> flagsExpr = Expression() ) ?
    <RPAREN>
      { return new XE_Regex(expr, patExpr, flagsExpr) ; }
}
XExpr SubstringExpression() :
{ XExpr expr1 ; XExpr expr2 = null ; XExpr expr3 = null ; }
{
    <SUBSTR>
    <LPAREN>
      expr1 = Expression()
      <COMMA>
      expr2 = Expression()
      ( <COMMA> expr3 = Expression() ) ?
    <RPAREN>
      { return new XE_StrSubstring(expr1, expr2, expr3) ; }
}
XExpr StrReplaceExpression() :
{ XExpr expr1 ; XExpr expr2 = null ; XExpr expr3 = null ; XExpr expr4 = null ;}
{
  <REPLACE>
  <LPAREN>
  expr1 = Expression()
  <COMMA> expr2 = Expression()
  <COMMA> expr3 = Expression()
  ( <COMMA> expr4 = Expression() ) ?
  <RPAREN>
  { return new XE_StrReplace(expr1,expr2,expr3,expr4) ; }
}
XExpr ExistsFunc() : { Element el ; }
{
   <EXISTS>
   el = GroupGraphPattern()
   { return new XE_Exists(el) ; }
}
XExpr NotExistsFunc() : { Element el ; }
{
   <NOT> <EXISTS>
   el = GroupGraphPattern()
   { return new E_NotExists(el) ; }
}
XExpr Aggregate() : { XAggregator agg = null ; XString sep = null ;
                     boolean distinct = false ;
                     XExpr expr = null ; XExpr expr2 = null ;
                     XExprList a = new XExprList() ;
                     XExprList ordered = new XExprList() ;
                     Token t ; }
{
  ( t = <COUNT> <LPAREN>
    ( <DISTINCT> { distinct = true ; } )?
    ( <STAR> | expr = Expression() )
    <RPAREN>
    { if ( expr == null ) { agg = XAggregatorFactory.createCount(distinct) ; }
      if ( expr != null ) { agg = XAggregatorFactory.createCountExpr(distinct, expr) ; }
    }
  | t = <SUM> <LPAREN> ( <DISTINCT> { distinct = true ; } )? expr = Expression() <RPAREN>
    { agg = XAggregatorFactory.createSum(distinct, expr) ; }
  | t = <MIN> <LPAREN> ( <DISTINCT> { distinct = true ; } )? expr = Expression() <RPAREN>
    { agg = XAggregatorFactory.createMin(distinct, expr) ; }
  | t = <MAX> <LPAREN> ( <DISTINCT> { distinct = true ; } )? expr = Expression() <RPAREN>
    { agg = XAggregatorFactory.createMax(distinct, expr) ; }
  | t = <AVG> <LPAREN> ( <DISTINCT> { distinct = true ; } )? expr = Expression() <RPAREN>
    { agg = XAggregatorFactory.createAvg(distinct, expr) ;
    }
  | t = <SAMPLE> <LPAREN> ( <DISTINCT> { distinct = true ; } )? expr = Expression() <RPAREN>
    { agg = XAggregatorFactory.createSample(distinct, expr) ;}
  | t = <GROUP_CONCAT>
    <LPAREN>
    (t = <DISTINCT> { distinct = true ; })?
    expr = Expression() { a.add(expr) ; }
    (<SEMICOLON> <SEPARATOR> <EQ> sep=XString())?
    <RPAREN>
    { agg = XAggregatorFactory.createGroupConcat(distinct, expr, sep, ordered) ; }
   )
   {
     if ( ! allowAggregatesInExpressions )
            throwParseException("Aggregate expression not legal at this point",
                                 t.beginLine, t.beginColumn) ;
   }
   { XExpr exprAgg = getQuery().allocXAggregate(agg) ;
     return exprAgg ; }
}
XExpr XiriOrFunction() : { XIRIref iri ; XExprList a = null ;
                         XExprList params = null ;
                         boolean distinct = false ; }
{
  iri = Xiri()
  (a = ArgList())?
  { if ( a == null )
       return iri ;
    
    if ( !iri.isString() ) {
      throwParseException("Custom expression not legal in place of a function IRI : "+iri, -1, -1) ;
    }
    if ( AggregateRegistry.isRegistered(iri.asString()) ) {
         if ( ! allowAggregatesInExpressions )
            throwParseException("Aggregate expression not legal at this point : "+iri, -1, -1) ;
         XAggregator agg = XAggregatorFactory.createCustom(true, false, iri, a) ;
         XExpr exprAgg = getQuery().allocXAggregate(agg) ;
         return exprAgg ;
      }
    return new XE_Function(iri, a) ;
  }
}
Node RDFLiteral() : { Token t ; String lex = null ; }
{
  lex = String()
  { String lang = null ; String uri = null ; }
  (
    ( t = <LANGTAG> { lang = stripChars(t.image, 1) ; } )
  |
    ( <DATATYPE> uri = iri() )
  )?
    { return createLiteral(lex, lang, uri) ; }
}
XRDFLiteral XRDFLiteral() : { Token t ; XString xstring; }
{
  xstring = XString()
  { String lang = null ; XIRIref xiri = null ; }
  (
    ( t = <LANGTAG> { lang = stripChars(t.image, 1) ; } )
  |
    ( <DATATYPE> xiri = XIRIREF() )
  )?
    { return new XRDFLiteral(xstring, lang, xiri) ; }
}
Node NumericLiteral() : { Node n ; }
{
  (
    n = NumericLiteralUnsigned()
  | n = NumericLiteralPositive()
  | n = NumericLiteralNegative()
  )
  { return n ; }
}
Node NumericLiteralUnsigned() : { Token t ; }
{
  t = <INTEGER> { return createLiteralInteger(t.image) ; }
| t = <DECIMAL> { return createLiteralDecimal(t.image) ; }
| t = <DOUBLE> { return createLiteralDouble(t.image) ; }
}
Node NumericLiteralPositive() : { Token t ; }
{
  t = <INTEGER_POSITIVE> { return createLiteralInteger(t.image) ; }
| t = <DECIMAL_POSITIVE> { return createLiteralDecimal(t.image) ; }
| t = <DOUBLE_POSITIVE> { return createLiteralDouble(t.image) ; }
}
Node NumericLiteralNegative() : { Token t ; }
{
  t = <INTEGER_NEGATIVE> { return createLiteralInteger(t.image) ; }
| t = <DECIMAL_NEGATIVE> { return createLiteralDecimal(t.image) ; }
| t = <DOUBLE_NEGATIVE> { return createLiteralDouble(t.image) ; }
}
Node BooleanLiteral() : {}
{
  <TRUE> { return XSD_TRUE ; }
 |
  <FALSE> { return XSD_FALSE ; }
}
String String() : { Token t ; String lex ; }
{
  ( t = <STRING_LITERAL1> { lex = stripQuotes(t.image) ; }
  | t = <STRING_LITERAL2> { lex = stripQuotes(t.image) ; }
  | t = <STRING_LITERAL_LONG1> { lex = stripQuotes3(t.image) ; }
  | t = <STRING_LITERAL_LONG2> { lex = stripQuotes3(t.image) ; }
  )
    {
      lex = unescapeStr(lex, t.beginLine, t.beginColumn) ;
      return lex ;
    }
}
XString XString() : { XString xstring ; }
{
  ( 
    xstring = XString_Literal1()
  | xstring = XString_Literal2()
  | xstring = XString_Literal_Long1()
  | xstring = XString_Literal_Long2()
  )
    {
      return xstring;
    }
}
XString XString_Literal1() : { XString xstring = new XString(); Token t; }
{
  ( t = <STRING_LITERAL1> 
    { String lex = stripQuotes(t.image) ;
      xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
  |
    t = <STRING_LITERAL1_START>
    { String lex = stripQuotes(t.image,1,2) ;
      xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
    XString_Literal1_Sub( xstring )
  )
  { return xstring; }
}
XString XString_Literal1_Sub(XString xstring) : { Token t; XExpr e; }
{ 
  e = Expression() { xstring.add( e ); }
  ( 
   ( t = <SUB_000000>
   | t = <SUB_100000>
   | t = <SUB_000100>
   | t = <SUB_000001>
   | t = <SUB_100001>
   | t = <SUB_000101>
   ) 
   { String lex = stripQuotes(t.image,1,2) ;
    xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
    XString_Literal1_Sub( xstring )
  | 
     t = <STRING_LITERAL1_END> 
     { String lex = stripQuotes(t.image) ;
       xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
  )
  { return xstring; }
}
XString XString_Literal2() : { XString xstring = new XString(); Token t; }
{
  ( t = <STRING_LITERAL2> 
    { String lex = stripQuotes(t.image) ;
      xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
  |
    t = <STRING_LITERAL2_START>
    { String lex = stripQuotes(t.image,1,2) ;
      xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
    XString_Literal2_Sub( xstring )
  )
  { return xstring; }
}
XString XString_Literal2_Sub(XString xstring) : { Token t; XExpr e; }
{ 
  e = Expression() { xstring.add( e ); }
  (
   ( t = <SUB_000000>
   | t = <SUB_010000>
   | t = <SUB_001000>
   | t = <SUB_000001>
   | t = <SUB_010001>
   | t = <SUB_001001>
   ) { xstring.add( stripQuotes(t.image,1,2) ); }
    XString_Literal2_Sub( xstring )
  | 
     t = <STRING_LITERAL2_END> { xstring.add( stripQuotes(t.image) ); }
  )
  { return xstring; }
}
XString XString_Literal_Long1() : { XString xstring = new XString(); Token t; }
{
  ( t = <STRING_LITERAL_LONG1> 
    { String lex = stripQuotes3(t.image) ;
      xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
  |
    t = <STRING_LITERAL_LONG1_START> 
    { String lex = stripQuotes(t.image,3,2) ;
      xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
    XString_Literal_Long1_Sub( xstring )
  )
  { return xstring; }
}
XString XString_Literal_Long1_Sub(XString xstring) : { Token t; XExpr e; }
{ 
  e = Expression() { xstring.add( e ); }
  ( 
   ( t = <SUB_000000>
   | t = <SUB_100000>
   | t = <SUB_010000>
   | t = <SUB_000100>
   | t = <SUB_000010>
   | t = <SUB_000001>
   | t = <SUB_100010>
   | t = <SUB_100001>
   | t = <SUB_010100>
   | t = <SUB_010010>
   | t = <SUB_010001>
   | t = <SUB_000110>
   | t = <SUB_000101>
   | t = <SUB_000011>
   | t = <SUB_010110>
   | t = <SUB_010101>
   | t = <SUB_000111>
   | t = <SUB_010111>
   )
    { String lex = stripQuotes(t.image,1,2) ;
      xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
    XString_Literal_Long1_Sub( xstring )
  | 
     t = <STRING_LITERAL_LONG1_END>
     { String lex = stripQuotes(t.image,1,3) ;
       xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
  )
  { return xstring; }
}
XString XString_Literal_Long2() : { XString xstring = new XString(); Token t; }
{
  ( t = <STRING_LITERAL_LONG2> 
    { String lex = stripQuotes3(t.image) ;
      xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
  |
    t = <STRING_LITERAL_LONG2_START> 
    { String lex = stripQuotes(t.image,3,2) ;
      xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
    XString_Literal_Long2_Sub( xstring )
  )
  { return xstring; }
}
XString XString_Literal_Long2_Sub(XString xstring) : { Token t; Expr e; }
{  
  e = Expression() { xstring.add( e ); }
  (
   ( t = <SUB_000000>
   | t = <SUB_100000>
   | t = <SUB_010000>
   | t = <SUB_001000>
   | t = <SUB_000010>
   | t = <SUB_000001>
   | t = <SUB_101000>
   | t = <SUB_100010>
   | t = <SUB_100001>
   | t = <SUB_010010>
   | t = <SUB_010001>
   | t = <SUB_001010>
   | t = <SUB_001001>
   | t = <SUB_000011>
   | t = <SUB_101010>
   | t = <SUB_101001>
   | t = <SUB_001011>
   | t = <SUB_101011>
   ) { xstring.add( stripQuotes(t.image,1,2) ); }
    XString_Literal_Long2_Sub( xstring )
  | 
     t = <STRING_LITERAL_LONG2_END>
     { String lex = stripQuotes(t.image,1,3) ;
       xstring.add( unescapeStr(lex, t.beginLine, t.beginColumn) ) ; }
  )
  { return xstring; }
}
String iri() : { String iri ; }
{
  iri = IRIREF() { return iri ; }
|
  iri = PrefixedName() { return iri ; }
}
XIRIref Xiri() : { XIRIref iri ; }
{
  iri = XIRIREF() { return iri ; }
|
  iri = XPrefixedName() { return iri ; }
}
String PrefixedName() : { Token t ; }
{
  ( t = <PNAME_LN>
    { return resolvePName(t.image, t.beginLine, t.beginColumn) ; }
  |
    t = <PNAME_NS>
    { return resolvePName(t.image, t.beginLine, t.beginColumn) ; }
  )
}
XIRIref XPrefixedName() : { Token t ; XIRIref ref = new XIRIref(); }
{
  ( t = <PNAME_LN> 
    { ref.add( resolvePName(t.image, t.beginLine, t.beginColumn) ) ; return ref ; }
  |
    t = <PNAME_NS> 
    { ref.add( resolvePName(t.image, t.beginLine, t.beginColumn) ) ; return ref ; }
  |
    t = <PNAME_LN_START>
    { String lex = resolvePName( stripQuotes(t.image,0,2) , t.beginLine, t.beginColumn) ;
      ref.add( lex ) ; }
    XPrefixedName_Sub( ref )
  )
  { return ref; }
}
XIRIref XPrefixedName_Sub(IRIref ref) : { Token t; XExpr e; }
{ 
  e = Expression() { ref.add( e ); }
  (
    t = <PNAME_LN_SUB>
    { ref.add( stripQuotes(t.image,1,2) ); }
    XPrefixedName_Sub( ref )
  | 
     t = <PNAME_LN_END> { ref.add( stripQuotes(t.image,1,0) ); }
  )
  { return ref; }
}
Node BlankNode() : { Token t = null ; }
{
  t = <BLANK_NODE_LABEL>
    { return createBNode(t.image, t.beginLine, t.beginColumn) ; }
|
  t = <ANON> { return createBNode(t.beginLine, t.beginColumn) ; }
}
String IRIREF() : { Token t ; }
{
  t = <IRIref>
  { return resolveQuotedIRI(t.image, t.beginLine, t.beginColumn) ; }
}
XIRIref XIRIREF() : { XIRIref ref = new XIRIref(); Token t;}
{
 (
  t = <IRIref>
  { ref.add( resolveQuotedIRI(t.image, t.beginLine, t.beginColumn) ); }
 |
  t = <XIRIref_START> { ref.add( stripQuotes(t.image,1,2) ); }
  ref = XIRIREF_Sub( ref )
 )
  { return ref; }
}
XIRIref XIRIREF_Sub(XIRIref ref) : {Token t; XExpr e;}
{
  e = Expression() { ref.add( e ); }
  ( 
   ( t = <SUB_000000>
   | t = <SUB_010000>
   | t = <SUB_001000>
   | t = <SUB_000001>
   | t = <SUB_010001>
   | t = <SUB_001001>
   ) { ref.add( stripQuotes(t.image,1,2) ); }
    ref = XIRIREF_Sub( ref )
  | 
     t = <XIRIref_END> { ref.add( stripQuotes(t.image) ); }
  )
  { return ref; }
}
SKIP : { " " | "\t" | "\n" | "\r" | "\f" }
SPECIAL_TOKEN :
{ <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }
TOKEN: {
  <#WS: " " | "\t" | "\n" | "\r" | "\f">
|
  <#WSC: <WS> | <SINGLE_LINE_COMMENT> >
|
  <BOM: "\uFEFF">
}
TOKEN:
{
   <IRIref: "<" (~[ ">","<", "\"", "{", "}", "$", "^", "\\", "|", "`",
                      "\u0000"-"\u0020"])* ">" >
|  <XIRIref_START: "<" (~[ ">","<", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020"])* "${" >
|  <XIRIref_END: "}" (~[ ">","<", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020"])* ">" >
| <PNAME_NS: (<PN_PREFIX>)? ":" >
| <PNAME_LN: <PNAME_NS> <PN_LOCAL> >
| <PNAME_LN_START: <PNAME_NS> ( (<PN_CHARS_U> | ":" | ["0"-"9"] | <PLX> )
                                   (<PN_CHARS> | "." |":" | <PLX> )* 
                                 )? "${" >
| <PNAME_LN_SUB: "}" ( <PN_CHARS> | "." |":" | <PLX> )* "${" >
| <PNAME_LN_END: "}" ( (<PN_CHARS> | "." |":" | <PLX> )*
                          (<PN_CHARS> | ":" | <PLX>) )? >
| <BLANK_NODE_LABEL: "_:" (<PN_CHARS_U> | ["0"-"9"]) ((<PN_CHARS>|".")* <PN_CHARS>)? >
| <VAR1: "?" <VARNAME> >
| <VAR2: "$" <VARNAME> >
| <LANGTAG: <AT> (<A2Z>)+("-" (<A2ZN>)+)* >
| <#A2Z: ["a"-"z","A"-"Z"]>
| <#A2ZN: ["a"-"z","A"-"Z","0"-"9"]>
}
TOKEN : { <KW_A: "a" > }
TOKEN [IGNORE_CASE] :
{
   < GENERATE: "generate" >
|  < SOURCE: "source" >
|  < ACCEPT: "accept" >
|  < ITERATOR: "iterator" >
}
TOKEN [IGNORE_CASE] :
{
   < BASE: "base" >
| < PREFIX: "prefix" >
| < SELECT: "select" >
| < DISTINCT: "distinct" >
| < REDUCED: "reduced" >
| < DESCRIBE: "describe" >
| < CONSTRUCT: "construct" >
| < ASK: "ask" >
| < LIMIT: "limit" >
| < OFFSET: "offset" >
| < ORDER: "order" >
| < BY: "by" >
| < VALUES: "values" >
| < UNDEF: "undef" >
| < ASC: "asc" >
| < DESC: "desc" >
| < NAMED: "named" >
| < FROM: "from" >
| < WHERE: "where" >
| < AND: "and" >
| < GRAPH: "graph" >
| < OPTIONAL: "optional" >
| < UNION: "union" >
| < MINUS_P: "minus" >
| < BIND: "bind" >
| < SERVICE: "service" >
| < EXISTS: "exists" >
| < NOT: "not" >
| < AS: "as" >
| < GROUP: "group" >
| < HAVING: "having" >
| < SEPARATOR: "separator" >
| < AGG: "agg" >
| < COUNT: "count" >
| < MIN: "min" >
| < MAX: "max" >
| < SUM: "sum" >
| < AVG: "avg" >
| < STDDEV: "stdev" >
| < SAMPLE: "sample" >
| < GROUP_CONCAT: "group_concat" >
| < FILTER: "filter" >
| < BOUND: "bound" >
| < COALESCE: "coalesce" >
| < IN: "in" >
| < IF: "if" >
| < BNODE: "bnode" >
| < IRI: "iri" >
| < URI: "uri" >
| < STR: "str" >
| < STRLANG: "strlang" >
| < STRDT: "strdt" >
| < DTYPE: "datatype" >
| < LANG: "lang" >
| < LANGMATCHES: "langmatches" >
| < IS_URI: "isURI" >
| < IS_IRI: "isIRI" >
| < IS_BLANK: "isBlank" >
| < IS_LITERAL: "isLiteral" >
| < IS_NUMERIC: "isNumeric" >
| < REGEX: "regex" >
| < SAME_TERM: "sameTerm" >
| < RAND: "RAND" >
| < ABS: "ABS" >
| < CEIL: "CEIL" >
| < FLOOR: "FLOOR" >
| < ROUND: "ROUND" >
| < CONCAT: "CONCAT" >
| < SUBSTR: "SUBSTR" >
| < STRLEN: "STRLEN" >
| < REPLACE: "REPLACE" >
| < UCASE: "UCASE" >
| < LCASE: "LCASE" >
| < ENCODE_FOR_URI: "ENCODE_FOR_URI" >
| < CONTAINS: "CONTAINS" >
| < STRSTARTS: "STRSTARTS" >
| < STRENDS: "STRENDS" >
| < STRBEFORE: "STRBEFORE" >
| < STRAFTER : "STRAFTER" >
| < YEAR: "YEAR" >
| < MONTH: "MONTH" >
| < DAY: "DAY" >
| < HOURS: "HOURS" >
| < MINUTES: "MINUTES" >
| < SECONDS: "SECONDS" >
| < TIMEZONE: "TIMEZONE" >
| < TZ: "TZ" >
| < NOW: "NOW" >
| < UUID: "UUID" >
| < STRUUID: "STRUUID" >
| < MD5: "MD5" >
| < SHA1: "SHA1" >
| < SHA224: "SHA224" >
| < SHA256: "SHA256" >
| < SHA384: "SHA384" >
| < SHA512: "SHA512" >
| < TRUE: "true" >
| < FALSE: "false" >
}
TOKEN [IGNORE_CASE] :
{
  < DATA: "data" >
| < INSERT: "insert">
| < DELETE: "delete" >
| < INSERT_DATA: <INSERT> (<WSC>)* <DATA> >
| < DELETE_DATA: <DELETE> (<WSC>)* <DATA> >
| < DELETE_WHERE: <DELETE> (<WSC>)* <WHERE> >
| < LOAD: "load" >
| < CLEAR: "clear" >
| < CREATE: "create" >
| < ADD: "add" >
| < MOVE: "move" >
| < COPY: "copy" >
| < META: "meta" >
| < SILENT: "silent" >
| < DROP: "drop" >
| < INTO: "into" >
| < TO: "to" >
| < DFT: "default" >
| < ALL: "all" >
| < WITH: "with" >
| < USING: "using" >
}
TOKEN :
{
  < #DIGITS: (["0"-"9"])+>
| < INTEGER: <DIGITS> >
| < DECIMAL: (<DIGITS>)? "." <DIGITS> >
| < DOUBLE:
      (
        (["0"-"9"])+ "." (["0"-"9"])* <EXPONENT>
        | "." (["0"-"9"])+ (<EXPONENT>)
        | (["0"-"9"])+ <EXPONENT>
      )
      >
| < INTEGER_POSITIVE: <PLUS> <INTEGER> >
| < DECIMAL_POSITIVE: <PLUS> <DECIMAL> >
| < DOUBLE_POSITIVE: <PLUS> <DOUBLE> >
| < INTEGER_NEGATIVE: <MINUS> <INTEGER> >
| < DECIMAL_NEGATIVE: <MINUS> <DECIMAL> >
| < DOUBLE_NEGATIVE: <MINUS> <DOUBLE> >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < #QUOTE_3D: "\"\"\"">
| < #QUOTE_3S: "'''">
| <ECHAR: "\\" ( "t"|"b"|"n"|"r"|"f"|"\\"|"\""|"'"|"$") >
| <STRING_LITERAL1: "'" ( (~["'","\\","\n","\r","$"]) | <ECHAR> )* "'" >
| <STRING_LITERAL1_START: "'" ( (~["'","\\","\n","\r","$"]) | <ECHAR> )* "${" >
| <STRING_LITERAL1_END: "}" ( (~["'","\\","\n","\r","$"]) | <ECHAR> )* "'" >
| <STRING_LITERAL2: "\"" ( (~["\"","\\","\n","\r","$"]) | <ECHAR> )* "\"" >
| <STRING_LITERAL2_START: "\"" ( (~["\"","\\","\n","\r","$"]) | <ECHAR> )* "${" >
| <STRING_LITERAL2_END: "}" ( (~["\"","\\","\n","\r","$"]) | <ECHAR> )* "\"" >
| <STRING_LITERAL_LONG1:
     <QUOTE_3S>
      ( ("'" | "''")? (~["'","\\","$"] | <ECHAR> ))*
     <QUOTE_3S> >
| <STRING_LITERAL_LONG1_START:
     <QUOTE_3S>
      ( ("'" | "''")? (~["'","\\","$"] | <ECHAR> ))*
     "${" >
| <STRING_LITERAL_LONG1_END:
     "}"
      ( ("'" | "''")? (~["'","\\","$"] | <ECHAR> ))*
     <QUOTE_3S> >
| <STRING_LITERAL_LONG2:
     <QUOTE_3D>
      ( ("\"" | "\"\"")? (~["\"","\\","$"] | <ECHAR> ))*
     <QUOTE_3D> >
| < STRING_LITERAL_LONG2_START:
     <QUOTE_3D>
      ( ("\"" | "\"\"")? (~["\"","\\","$"] | <ECHAR> ))*
     "${" >
| < STRING_LITERAL_LONG2_END:
     "}"
      ( ("\"" | "\"\"")? (~["\"","\\","$"] | <ECHAR> ))*
     <QUOTE_3D> >
}
TOKEN : {
  <SUB_000000: "}" ( ~[">", "<", "'", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020","\n","\r"] )* "${" >
| <SUB_100000: "}" ( ("\"" | "\"\"")? ~[">", "<", "'", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020","\n","\r"] )* "${" >
| <SUB_010000: "}" ( ("'" | "''")?    ~[">", "<", "'", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020","\n","\r"] )* "${" >
| <SUB_001000: "}" ( ~[">", "<", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020","\n","\r"] )* "${" >
| <SUB_000100: "}" ( ~[">", "<", "'", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020","\n","\r"] )* "${" >
| <SUB_000010: "}" ( ~[">", "<", "'", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020"] )* "${" >
| <SUB_000001: "}" ( ~["'", "\"", "$", "\\", "\n","\r"] | <ECHAR> )* "${" >
| <SUB_101000: "}" ( ("\"" | "\"\"")? ~[">", "<", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020","\n","\r"] )* "${" >
| <SUB_100010: "}" ( ("\"" | "\"\"")? ~[">", "<", "'", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020"] )* "${" >
| <SUB_100001: "}" ( ("\"" | "\"\"")? ~["'", "\"", "$", "\\", "\n","\r"] | <ECHAR> )* "${" >
| <SUB_010100: "}" ( ("'" | "''")?    ~[">", "<", "'", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020","\n","\r"] )* "${" >
| <SUB_010010: "}" ( ("'" | "''")?    ~[">", "<", "'", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020"] )* "${" >
| <SUB_010001: "}" ( ("'" | "''")?    ~["'", "\"", "$", "\\", "\n","\r"] | <ECHAR> )* "${" >
| <SUB_001010: "}" ( ~[">", "<", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020"] )* "${" >
| <SUB_001001: "}" ( ~["\"", "$", "\\", "\n","\r"] | <ECHAR> )* "${" >
| <SUB_000110: "}" ( ~[">", "<", "'", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020"] )* "${" >
| <SUB_000101: "}" ( ~["'", "$", "\\", "\n","\r"] | <ECHAR> )* "${" >
| <SUB_000011: "}" ( ~["'", "\"", "$", "\\"] | <ECHAR> )* "${" >
| <SUB_101010: "}" ( ("\"" | "\"\"")? ~[">", "<", "\"", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020"] )* "${" >
| <SUB_101001: "}" ( ("\"" | "\"\"")? ~["\"", "$", "\\", "\n","\r"] | <ECHAR> )* "${" >
| <SUB_010110: "}" ( ("'" | "''")?    ~[">", "<", "'", "{", "}", "$", "^", "\\", "|", "`", "\u0000"-"\u0020"] )* "${" >
| <SUB_010101: "}" ( ("'" | "''")?    ~["'", "$", "\\", "\n","\r"] | <ECHAR> )* "${" >
| <SUB_001011: "}" ( ~["\"", "$", "\\"] | <ECHAR> )* "${" >
| <SUB_000111: "}" ( ~["'", "$", "\\"] | <ECHAR> )* "${" >
| <SUB_101011: "}" ( ("\"" | "\"\"")? ~["\"", "$", "\\"] | <ECHAR> )* "${" >
| <SUB_010111: "}" ( ("'" | "''")?    ~["'", "$", "\\"] | <ECHAR> )* "${" >
}
TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| <NIL: <LPAREN> (<WSC>)* <RPAREN> >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < ANON: <LBRACKET> (<WSC>)* <RBRACKET> >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < EQ: "=" >
| < NE: "!=" >
| < GT: ">" >
| < LT: "<" >
| < LE: "<=" >
| < GE: ">=" >
| < BANG: "!" >
| < TILDE: "~" >
| < COLON: ":" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < DATATYPE: "^^">
| < AT: "@">
| < VBAR: "|" >
| < CARAT: "^" >
| < FPATH: "->" >
| < RPATH: "<-" >
| < QMARK: "?" >
| < START_XEXPR: "${" >
}
TOKEN:
{
  <#PN_CHARS_BASE:
          ["A"-"Z"] | ["a"-"z"] |
          ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] | ["\u00F8"-"\u02FF"] |
          ["\u0370"-"\u037D"] | ["\u037F"-"\u1FFF"] |
          ["\u200C"-"\u200D"] | ["\u2070"-"\u218F"] | ["\u2C00"-"\u2FEF"] |
          ["\u3001"-"\uD7FF"] | ["\uF900"-"\uFFFD"]
          >
|
  <#PN_CHARS_U: <PN_CHARS_BASE> | "_" >
|
  <#PN_CHARS: (<PN_CHARS_U> | "-" | ["0"-"9"] | "\u00B7" |
              ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] ) >
|
  <#PN_PREFIX: <PN_CHARS_BASE> ((<PN_CHARS>|".")* <PN_CHARS>)? >
|
  <#PN_LOCAL: (<PN_CHARS_U> | ":" | ["0"-"9"] | <PLX> )
              ( (<PN_CHARS> | "." |":" | <PLX> )*
                (<PN_CHARS> | ":" | <PLX>) )? >
|
  <#VARNAME: ( <PN_CHARS_U> | ["0"-"9"] )
             ( <PN_CHARS_U> | ["0"-"9"] | "\u00B7" |
               ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] )* >
|
  < #PN_LOCAL_ESC: "\\"
          ( "_" |
            "~" | "." | "-" | "!" | "$" | "&" | "'" |
           "(" | ")" | "*" | "+" | "," | ";" | "=" |
           "/" | "?" | "#" | "@" | "%" ) >
|
  <#PLX: <PERCENT> | <PN_LOCAL_ESC> >
|
  < #HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"] >
|
  < #PERCENT: "%" <HEX> <HEX> >
}
TOKEN:
{
  <#UNKNOWN: (~[" ","\t","\n","\r","\f" ])+ >
}
